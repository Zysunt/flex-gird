<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flex与canvas</title>
<style>
/*这里的样式为接下来的所有页面的样式*/
.container{
    width: 50%;
    display: grid;
    grid-template-columns: repeat(auto-fill,150px);
    background-color: #cad6f0;
    box-shadow: 8px 7px 8px 3px rgb(9 2 4 / 10%);
}
.container2{
    width: 50%;
    display: grid;
    grid-template-columns: repeat(auto-fill,300px);
    background-color: #caf0d0;
    box-shadow: 8px 7px 8px 3px rgb(9 2 4 / 10%);
}
.container1{
    width: 50%;
    display: grid;
    grid-gap: 10px;
    grid-template-columns: 120px  120px  120px;
    grid-template-areas:
            ". header  header "
            "sidebar content content"
            "footer footer footer";
    /*划分9个单元格，. （点）代表这个区域没有用到*/
    background-color: #cad6f0;
    box-shadow: 8px 7px 8px 3px rgb(9 2 4 / 10%);
}
.box{
    width: 100px;
    height: 100px;
    margin: 10px;
    color: #fff;
    background-color: rgb(95 169 103 / 71%);
}
.sidebar {
    grid-area: sidebar;
}
.footer{
    grid-area: footer;
}
.content {
    grid-area: content;
}

.header {
    grid-area: header;
}
.box1{
    color: #fff;
    border-radius: 5px;
    padding: 20px;
    font-size: 150%;
    background-color: rgb(17, 183, 205);
}
.box2{
    width: 150px;
    height: auto;
    background-color: #1d63cb;
}
.box3{
    width: 150px;
    background-color: #ac2351;
}
.container3{
    display: grid;
    grid-template-columns: repeat(auto-fill,200px);
    grid-template-rows: repeat(3,120px);/*添加纵向间隙*/
    grid-gap: 15px;
    background-color: rgb(215, 250, 231);
    box-shadow:  0px 2px 2px 0px rgba(9, 2, 4, 0.1);
}
.box03{
    width: 100px;
    height: 100px;
    color: #fff;
    background-color: rgb(95 169 103 / 71%);
}
</style>
</head>
<body>
    <h3>place-items: center center-- 在单元格内，box的位置在中间（上下左右间距相等 ）</h3>
<div class="container3" style="place-items: center center">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
    <h3>place-items: start end-- 在单元格内，box的位置在右上角</h3>
<div class="container3" style="place-items: start end">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
    <h3>align-items: start</h3>
<div class="container3" style="align-items: start">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
<h3>align-items: center</h3>
<div class="container3" style="align-items: center">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
    <!--当前项目在单元格中的水平位置-->
<h3>justify-items: start</h3>
<div class="container3" style="justify-items: start">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
<h3>justify-items: center</h3>
<div class="container3" style="justify-items: center">
    <div class="box03">11</div>
    <div class="box03">22</div>
    <div class="box03">33</div>
    <div class="box03">44</div>
    <div class="box03">55</div>
</div>
    <h3>grid-auto-flow: row;</h3>
<div class="container" style="grid-auto-flow: row;">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
    <div class="box">55</div>
    <div class="box">66</div>
    <div class="box">77</div>
    <div class="box">88</div>
</div>
<h3>grid-auto-flow: row dense;</h3>
<!--设置了grid-auto-flow: row dense; dense 这个属性值之后就会让其容器内尽可能的多排练一些内容，而不会很大的空隙-->
<div class="container2" style="grid-auto-flow: row dense;">
    <div class="box">11</div>
    <div style="height: 100px;width: 200px;margin:10px;background-color: rgb(23, 71, 193)">22</div>
    <div class="box">33</div>
    <div style="height: 100px;width: 150px;margin:10px;background-color: rgb(111, 22, 22)">44</div>
    <div class="box">55</div>
    <div class="box">66</div>
    <div class="box" style="width: 260px;margin:10px;background-color: rgb(22, 111, 59)">77</div>
    <div class="box">88</div>
</div>

<h3>sidebar</h3>
<div class="container1">
    <div class=" box1 sidebar">sidebar</div>
    <div class=" box1 content">content</div>
    <div class=" box1 footer">footer</div>
    <div class=" box1 header">header</div>
</div>

    <p><strong>设置的间距之对于当前的行列的内部有效</strong></p>
<h3>grid-gap: 20px;</h3>
<div class="container" style="grid-gap: 20px;">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
</div>
<h3>grid-column-gap: 20px;grid-row-gap: 20px;</h3>
<div class="container" style="grid-column-gap: 20px;grid-row-gap: 20px;">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
</div>


    <!--将容器的宽度分为4份，第一列和第二列宽度为1/4，第三列的宽度为最小为300px,最大占2/4的宽度-->
<h3>grid-template-columns: 1fr 1fr minmax(300px,2fr)</h3>
<div class="container" style="height:100px;grid-template-columns: 1fr 1fr minmax(300px,2fr);">
    <div style="background-color: rgb(17, 183, 205)">11</div>
    <div style="background-color: #2380ac">22</div>
    <div style="background-color: #23ac86">33</div>
</div>
<!--获取3列，第一列和第三列的宽度为固定值100px,第二列更具屏幕的大小自动计算宽度-->
<h3>grid-template-columns: 100px auto 100px</h3>
<div class="container" style="height:100px;grid-template-columns: 100px auto 100px">
    <div style="background-color: rgb(17, 183, 205)">11</div>
    <div style="background-color: #2380ac">22</div>
    <div style="background-color: #23ac86">33</div>
</div>


    <!--获取3列，项目的第一列的宽度为100px,将剩余空间分成3等分，第二列宽度为1/3的宽，第三列的宽度为2/3的宽-->
<h3>grid-template-columns: 100px 1fr 2fr</h3>
<div class="container" style="height:100px;grid-template-columns: 100px 1fr 2fr;">
    <div style="background-color: rgb(17, 183, 205)">11</div>
    <div style="background-color: #2380ac">22</div>
    <div style="background-color: #23ac86">33</div>
</div>



<!--设置一行有3列，且每个项目的宽度为200px-->
<h3>grid-template-columns: repeat(3,200px);</h3>
<div class="container" style="grid-template-columns: repeat(3,200px);">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
</div>
<!--和上面的代码等价-->
<h3>grid-template-columns: 200px 200px 200px;</h3>
<div class="container" style="grid-template-columns: 200px 200px 200px;">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
</div>
<!--在容器中能排列下的情况下京可能的多排列，每个项目的宽度为200px-->
<h3>grid-template-columns: repeat(auto-fill,200px);</h3>
<div class="container" style="grid-template-columns: repeat(auto-fill,200px);">
    <div class="box">11</div>
    <div class="box">22</div>
    <div class="box">33</div>
    <div class="box">44</div>
    <div class="box">55</div>
    <div class="box">66</div>
    <div class="box">77</div>
</div>



    <!-- <canvas class="bg" id="canvas"></canvas> -->
<canvas id="canvas1" width="600" height="600"></canvas>
    <script>
        // const canvas = document.getElementById('canvas')
        // const ctx = canvas.getContext('2d')
        // ctx.fillStyle = 'green'
        // ctx.fillRect(20,20,150,100);
    </script>
    <script>
         // 实现一个防抖函数（debounce）。防抖：函数在一段时间内的多次调用，仅使得最后一次调用有效。
        function debounce(fn, delay, immediate) {
            let timer
            let result
            return function(...args) {
                if (timer) clearTimeout(timer)
                if (immediate) {
                // 如果timer存在，说明第二次调用的时候还没到delay时间，因为如果超过delay时间
                // timer会被赋值为null，所以这个时候我们不应该执行fn，应该重新设置一个定时器
                // 但如果是一次的时候，因为还没有设过定时器，所以这里timer会是undefined
                if (timer) {
                    timer = setTimeout(() => timer = null, delay)
                } else {
                    result = fn.apply(this, args)
                    return result
                }
                } else {
                timer = setTimeout(() => fn.apply(this, args), delay)
                }
            }
        }
        // 找出一个字符串中出现次数最多的字符，并统计出现的次数
        // computeString('djaskdhsajfhdsbfhebfbadsbcbhsgdjashkldjdnxjhsagfdhdgsfdsdfjdskfjkfdsjfsdsd')
        // '最多次数15的字母d,对象为{char:d,count:15}'
        function computeString(str){
            // 第一步是先把每个字母出现的次数计算出来; 
            // 第二步是把出现最多的那个字母和次数找出来
            let obj = {}// 记录着每一个字符及其出现的次数
            // 数组去重 和计算出现的次数
            for (let i = 0; i < str.length; i++) {
                const char = str.charAt(i)// str[i]; char就是对象obj的一个属性，obj[char]是属性值，obj[char]控制出现的次数
                if(obj[char]){// char这个元素已经存在过
                    obj[char]++// 次数加一
                }else{
                    obj[char] = 1// 第一次出现
                }
            }
            console.log(obj)
            let max = 0// 最大次数
            let charMax = null// key
            // obj 每一个字符 和出现的次数 遍历对象obj，找到出现次数最多的字符和次数
            for (const key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    const item = obj[key];
                    if (max < item) {
                        max = item// 出现最多次数
                        charMax = key// 出现最多的字符
                    }
                }
            }
            return `最多次数${max}的字母${charMax},对象为{char:${charMax},count:${max}}`
        }
        // 实现一个名为 uniqueArray 的函数，去掉数组里面重复的内容
        // [1, 1, 2, 3, 3, 1] => [1,2,3]

        function uniqueArray(arr){
        // Array.from(new Set([1, 1, 2, 3, 3, 1]))
        // (3) [1, 2, 3]
        return [...new Set([1, 1, 2, 3, 3, 1])]
        // (3) [1, 2, 3]
        }
        // 实现一个名为 urlToObj 的函数，将一个 url 中的参数转换成对象，入参为 url，返回的结果为对象。
        // let httpUrlStr = 'https://www.whatever.com?name=zhangsan&age=18&name1=zhangsan&age1=18';
        // { "name": "zhangsan", "age":  "18" }
        function getUrlParam() {
            let ret = {};
            for (let x of window.location.href.split('?')[1].split('&')) {
                ret[x.split('=')[0]]= x.split('=')[1];
            }
            return ret;
        }
        function getUrlParam() {
            const ret = window.location.href.split('?')[1].split('&').map(v=>
                ({
                [v.split('=')[0]]: v.split('=')[1]
                })
            )
            return Object.assign(...ret);
        // 深拷贝 JSON.parse(JSON.stringify(window.location.href.split('?')[1].split('&').map(i=>({[i.split('=')[0]]:i.split('=')[1]}))))
        }
        function urlToObj(url){
            let obj = {}
            if(!url) return 
            let queryArr =  url.split('?')[1].split('&')// name=zhangsan&age=18
            queryArr.forEach(element => {
                let arr = element.split('=')
                obj[arr[0]] = arr[1]
            });
            return obj
        }
    </script>
    <script>
    const canvas = document.getElementById('canvas1')
    const ctx = canvas.getContext('2d')
    ctx.fillStyle = 'purple'
    const step = 1 // 每步的长度
    let xPosition = 0 // x坐标
    function move() {
        ctx.clearRect(0, 0, 600, 600)
        ctx.fillRect(xPosition, xPosition, 300, 150)
        xPosition += step
        if (xPosition <= 300) {
            requestAnimationFrame(() => {
                move()
            })
        }
    }
    move() // call move
 
    </script>
</body>
</html>